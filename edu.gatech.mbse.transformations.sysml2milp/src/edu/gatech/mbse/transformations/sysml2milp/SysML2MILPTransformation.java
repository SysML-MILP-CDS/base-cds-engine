/**
 * Copyright (c) 2015, Model-Based Systems Engineering Center, Georgia Institute of Technology.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided
 * that the following conditions are met:
 * 
 *    Redistributions of source code must retain the above copyright notice, this list of conditions and the
 *    following disclaimer.
 * 
 *    Redistributions in binary form must reproduce the above copyright notice, this list of conditions and
 *    the following disclaimer in the documentation and/or other materials provided with the distribution.
 *   
 *    Neither the name of salesforce.com, inc. nor the names of its contributors may be used to endorse or
 *    promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
package edu.gatech.mbse.transformations.sysml2milp;

import java.util.ArrayList;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.eclipse.uml2.uml.Activity;
import org.eclipse.uml2.uml.Classifier;
import org.eclipse.uml2.uml.Constraint;
import org.eclipse.uml2.uml.Element;
import edu.gatech.mbse.transformations.sysml2milp.ocl.MiniOCLInterpretor;
import edu.gatech.mbse.transformations.sysml2milp.utils.DSEMLUtils;
import edu.gatech.mbse.transformations.sysml2milp.utils.MILPModel2TextUtils;
import edu.gatech.mbse.transformations.sysml2milp.utils.MILPModel2TextUtilsYALMIP;
import edu.gatech.mbse.transformations.sysml2milp.utils.UMLModelUtils;

/**
 * SysML to MILP transformation.
 * <P>
 * Currently, a "shortcut" is taken, i.e., SysML Model -> Solver Specific Syntax.
 * Ideally, this should occur in multiple stages, which should be done in future
 * versions of this transformation:<BR />
 * 1) SysML -> Instance: number of instances determined by functional spec<BR />
 * 2) Instance -> MILP Model<BR />
 * 3) MILP Model -> Tool-Specific Textual Syntax<BR />
 * Required for this are a proper DSML, or generation of instances on SysML / UML
 * side, MILP meta-model. While sketches of all of this exists, implementation would
 * take quite a while. The transformation as currently is in this file should be
 * seen as an intermediate step towards this goal.
 * 
 * @author Sebastian
 * @version 0.1.2
 */
public class SysML2MILPTransformation {
	
	/** Log4J object. */
	private static final Logger logger = LogManager.getLogger(SysML2MILPTransformation.class.getName());
	
	/** Root model element. */
	private Element rootModelElement = null;
	
	/** Functional specification. */
	private Activity functionalSpecification = null;
	
	/** YALMIP-specific textual generation of MILP code. */
	private MILPModel2TextUtils milpModel2Text = null;
	
	/** String that can be accessed from outside that holds visualization information. */
	private static String resultsVisualizationBuffer = "";
	
	/** In continuous integration / unit testing system? */
	public static boolean TESTING_MODE = false;

	/**
	 * Constructor.
	 * <P>
	 * Sets up the transformation utilities.
	 */
	public SysML2MILPTransformation() {
		setupTransformationUtils();
	}
	
	/**
	 * Set up all utility classes that are used in the transformation. Currently
	 * this is the MILP code generation object.
	 */
	private void setupTransformationUtils() {
		// Should probably be made configurable, but since this is the only choice
		// right now, this is taken as default:
		setMilpModel2Text(new MILPModel2TextUtilsYALMIP());
	}
	
	/**
	 * Execute the transformation.
	 * <p>
	 * This function transforms a given SysML activity to a MILP problem. It
	 * returns MILP code that conforms to the syntax of the configured target
	 * environment.
	 * 
	 * @param topLevelActivity The functional specification (UML Activity).
	 * @param rootElement The root model element.
	 * @param numSolutions The number of solutions that the MILP solver should
	 * 		generate.
	 * @param testingMode If on, no excel output or instance data will be
	 * 		generated by the MILP solving environment. Instead, a temporary
	 * 		file writing all displayed results to a file is created. This is
	 * 		typically only set to true in the continuous integration system or
	 * 		when running JUnit tests.
	 * @return The generated MILP code.
	 * @throws Exception Thrown if the transformation failed to find a system
	 * 		under design or an objective.
	 */
	public String transform(Activity functionalSpec,
			Element rootElement,
			int numSolutions,
			boolean testingMode) throws Exception {
		/************* SETUP *************/
		
		// String buffer object - is faster for large strings
		StringBuffer milpCode = new StringBuffer();
		
		// Store input
		setRootModelElement(rootElement);
		MiniOCLInterpretor.rootModelElement = rootElement;		// Remove this in future
		SysML2MILPTransformation.TESTING_MODE = testingMode;
		setFunctionalSpecification(functionalSpec);
		
		// Reset transformation state variables
		TransformationState.resetState();
		
		// Reset visualization cache
		setResultsVisualizationBuffer("");
		
		// Rebuild cache & reset internal correspondences before transformation - note that
		// the cache is static
		TransformationCache.rebuildCache(getRootModelElement(), getFunctionalSpecification());		// Parses model and stores lists of commonly queried types of elements
		InternalCorrespondences.resetInternalCorrespondences();
		
		// Also, precompute some of the internal correspondences and reset state afterwards
		preComputeInternalCorrespondences();
		TransformationState.resetState();
		
		// We're using the visualization buffer to store code to write correspondences - add the corresponding preamble first
		if (!testingMode)
			appendResultsVisualizationBuffer(SysML2MILPMappingsHelper.generateInstanceDataOutputFilePreamble());
		
		
		
		
		/************* MAPPINGS *************/
				
		// Determine number of, and generate necessary instances of resources
		// and translate these to MILP
		String milpMachineInstances = transformResourceLibrary();
		
		// Map / translate the functional specification (activity "instances" where
		// WorkingPrinciples are taken as concrete implementations of abstract
		// activities).
		String milpFunctionalSpecification = transformFunctionalSpecification();

		// Find and translate system under design and objective
		String milpSystemUnderDesign = transformSystemUnderDesign();
		
		// Start by declaring some standard variables (duration, throughput, ...).
		// These are used throughout the MILP script, so have to included up front.
		// However, their determination requires other parts of the transformation
		// to have completed, hence the computation occurs at the end.
		String milpStandardVariables = SysML2MILPMappingsHelper.declareStandardVariables(getMilpModel2Text());
		
		// Transform aspects of the model that require both function and structure
		// to be defined already - for instance, the resource shareability constraints
		// refer to both functions (or, rather, their existence variables) and resource
		// instances.
		String milpFunctionStructureDependentConstraints = transformFunctionStructureDependentConstraints();
		
		
		
		
		/************* ASSEMBLE MILP CODE *************/
		
		// Preamble
		milpCode.append(
				getMilpModel2Text().generatePreamble());
		
		// Add all transformed sections to final MILP string
		milpCode.append(milpStandardVariables);
		milpCode.append(milpMachineInstances);
		milpCode.append(milpFunctionalSpecification);
		milpCode.append(milpFunctionStructureDependentConstraints);
		milpCode.append(milpSystemUnderDesign);
		
		// We're using the visualization buffer to store code to write correspondences - add the corresponding postamble last
		if (!testingMode)
			appendResultsVisualizationBuffer(SysML2MILPMappingsHelper.generateInstanceDataOutputFilePostamble());
		
		// Postamble, with visualization injected
		milpCode.append(
				getMilpModel2Text().generatePostamble(
						getResultsVisualizationBuffer(), 
						numSolutions, 
						testingMode));
		
		// Finally, return the MILP program
		return milpCode.toString();
	}

	/**
	 * @see SysML2MILPTransformation#transform(Activity, Element, int, boolean)
	 * 
	 * @throws Exception
	 */
	public String transform(Activity topLevelActivity, Element rootElement) throws Exception {
		return transform(topLevelActivity, rootElement, 1, false);
	}
	
	/**
	 * @see SysML2MILPTransformation#transform(Activity, Element, int, boolean)
	 * 
	 * @throws Exception
	 */
	public String transform(Activity topLevelActivity, Element rootElement, int numSolutions) throws Exception {
		return transform(topLevelActivity, rootElement, numSolutions, false);
	}
	
	/**
	 * Transform the system under design defined in the SysML model.
	 * 
	 * @return MILP code representing and defining the system under design.
	 * @throws Exception If system under design or objective could not be
	 * 		located in model.
	 */
	private String transformSystemUnderDesign() throws Exception {
		// Find and translate system under design
		Classifier systemUnderDesign = DSEMLUtils.getSystemUnderDesign(getFunctionalSpecification().getOwner());
		
		if (systemUnderDesign == null)
			systemUnderDesign = DSEMLUtils.getSystemUnderDesign(getRootModelElement());
		
		if (systemUnderDesign == null) {
			logger.log(Level.ERROR, "Could not find system under design in model.");
			
			throw new Exception("Could not find system under design in model.");
		}
		
		String milpSystemUnderDesignHeader = getMilpModel2Text().generateComment("System under design definition");
		String milpSystemUnderDesign = SysML2MILPMappings.mapSystemUnderDesign(systemUnderDesign, getMilpModel2Text());
		
		
		// Find and translate objective
		Constraint objective = DSEMLUtils.getObjective(systemUnderDesign);
		
		if (objective == null) {
			logger.log(Level.ERROR, "Could not find objective in model.");
			
			throw new Exception("Could not find objective in model.");
		}
		
		String milpObjectiveHeader = getMilpModel2Text().generateComment("Objective function");
		String milpObjective = SysML2MILPMappings.mapObjective(objective, getMilpModel2Text());
		
		// Return both
		return milpSystemUnderDesignHeader
				+ milpSystemUnderDesign
				+ milpObjectiveHeader
				+ milpObjective;
	}
	
	/**
	 * Transform the resources in the resource library. This step involves:<BR />
	 * 1) Determining the number of necessary instances for a given resource
	 * type<BR />
	 * 2) Creating instances in the background (not explicitly) and mapping these
	 * into MILP code
	 * 
	 * @return MILP code representing possible resource instances or the empty
	 * 		string if no resources are relevant to the problem.
	 */
	private String transformResourceLibrary() {
		String milpCode = "";
		
		// Used for assigning internal IDs to resource types (should be part of a
		// Resource object at some point in the future)
		int currentResourceID = 1;

		// Re-order
		// FIXME This will also need a dependency graph since, hypothetically, composite resources can contain
		//		 other composite resources.
		Element[] resourcesToProcess = getResourcesInProcessingOrder();
		
		// For each machine type, determine the maximum amount of instances
		// possibly necessary, and map these to MILP
		for (Element r : resourcesToProcess) {
			// Determine the maximum number of instances that can exist given the process
			int maxInstances = determineMaxPossibleInstances((Classifier) r);

			// Perform the actual mapping
			// Note that this actually maps both information about the type, and the resource instances
			milpCode += SysML2MILPMappings.mapResource((Classifier) r, currentResourceID, maxInstances, getMilpModel2Text());
			
			currentResourceID++;
		}
		
		// Note that resource shareability constraints have to be added after the functional
		// specification has been mapped - these constraints refer to variables defined
		// only thereafter.
		
		return milpCode;
	}
	
	/**
	 * Transforms the functional specification.
	 * <P>
	 * This function simply calls
	 * {@link SysML2MILPMappings#mapFunctionalSpecification(Activity, MILPModel2TextUtils)}.
	 * 
	 * @return MILP representation of the functional specification.
	 */
	private String transformFunctionalSpecification() {
		String milpCode = "";
		
		// Map the functional specification
		milpCode += SysML2MILPMappings.mapFunctionalSpecification(getFunctionalSpecification(), getMilpModel2Text());

		return milpCode;
	}
	
	/**
	 * Transforms shareability constraints.
	 * <P>
	 * Simply calls
	 * {@link SysML2MILPMappingsHelper#addResourceShareabilityConstraints(MILPModel2TextUtils)}.
	 * 
	 * @return MILP code that contains a set of constraints.
	 */
	private String transformFunctionStructureDependentConstraints() {
		// Add resource shareability constraints
		return SysML2MILPMappingsHelper.addResourceShareabilityConstraints(getMilpModel2Text());
	}
	
	/**
	 * Pre-compute all internal correspondences. These internal correspondences are used to determine
	 * which string representations various objects will have in the output MILP.
	 */
	private void preComputeInternalCorrespondences() {
		// Structure IDs & max instances for each resource
		// Used for assigning internal IDs to resource types (should be part of a
		// Resource object at some point in the future)
		int currentResourceID = 1;
		
		// Re-order
		// FIXME This will also need a dependency graph since, hypothetically, composite resources can contain
		//		 other composite resources.
		Element[] resourcesToProcess = getResourcesInProcessingOrder();
		
		// For each machine type, determine the maximum amount of instances
		// possibly necessary, and map these to MILP
		for (Element r : resourcesToProcess) {
			// Determine the maximum number of instances that can exist given the process
			int maxInstances = determineMaxPossibleInstances((Classifier) r);

			// Array of integers representing instance IDs
			ArrayList<Integer> instances = new ArrayList<Integer>();
			
			// Add a resource -> machine ID mapping (later this machine ID would be a
			// property of a Resource object)
			InternalCorrespondences.getResourceTypeMachineIDMapping().put(r, currentResourceID);
			
			// Add instance IDs to array of instance IDs (note: this is an ugly
			// regression - needs to be fixed (and will disappear when objects are
			// used for Resources and ResourceInstances)
			for (int i=1; i<maxInstances+1; i++)
				instances.add(i);

			// Add to mapping from resources to instances
			InternalCorrespondences.getResourceTypeInstanceIDMapping().put(r, instances);

			currentResourceID++;
		}
		
		// Function -> Structure Mappings
		InternalCorrespondences.preComputeFunctionStructureCorrespondences(getFunctionalSpecification());
	}
	
	/**
	 * Re-orders list of resources into an array such that composites come last.
	 * This is done because parts of composites must be defined before the composites
	 * themselves.
	 * 
	 * @return An array of UML Elements representing resources in the order that they
	 * 		should be processed within the transformation.
	 */
	private Element[] getResourcesInProcessingOrder() {
		Element[] resourcesToProcess = new Element[TransformationCache.getResources().size()];
		
		int currentCompositeIndex = TransformationCache.getResources().size() - 1;
		int normalIndex = 0;
		
		// Re-order sequence of translating resources - composites should come last
		// since parts must first be defined
		for (Element r : TransformationCache.getResources())
			if (DSEMLUtils.isCompositeResource(r))
				resourcesToProcess[currentCompositeIndex--] = r;
			else
				resourcesToProcess[normalIndex++] = r;
		
		return resourcesToProcess;
	}
	
	/**
	 * Determines the maximum number of instances for a given resource within the
	 * context of a particular functional specification.
	 * 
	 * @param resource The resource type.
	 * @return The maximum number of instances possibly required in any solution.
	 */
	private int determineMaxPossibleInstances(Classifier resource) {
		// TODO Do this in a cached map in future to improve performance?
		//		HashMap<Element, Integer> resourceMaxInstancesMapping = new HashMap<Element, Integer>();
		
		// 2015-08-18: Since only one working principle is part of a solution, and working
		//		principles can share the same type of resource, only get the max number
		//		necessary.
		
		// Collect all working principles that are relevant
		int maxPossibleInstances = 0;
		ArrayList<Activity> allActs = UMLModelUtils.collectSubActivities(getFunctionalSpecification());
		
		for (Activity act : allActs) {
			ArrayList<Activity> relWPs = DSEMLUtils.getWorkingPrinciples(act, TransformationCache.getAllWorkingPrinciples());
			
			int mostForAct = 0;
			
			for (Activity wp : relWPs) {
				int numRequired = 0;
				
				// For each working principle, collect the associated resources
				for (Element assocResource : DSEMLUtils.getResourceTypesWithDuplicates(wp)) {
					if (DSEMLUtils.isTypeOfResource((Classifier) assocResource, (Classifier) resource))
						numRequired++;
				}
				
				if (numRequired > mostForAct)
					mostForAct = numRequired;
			}
			
			maxPossibleInstances += mostForAct;
		}
		
		return maxPossibleInstances;
	}

	/**
	 * @return the rootModelElement
	 */
	private Element getRootModelElement() {
		return rootModelElement;
	}

	/**
	 * @param rootModelElement the rootModelElement to set
	 */
	private void setRootModelElement(Element rootModelElement) {
		this.rootModelElement = rootModelElement;
	}

	/**
	 * @return the functionalSpecification
	 */
	public Activity getFunctionalSpecification() {
		return functionalSpecification;
	}

	/**
	 * @param functionalSpecification the functionalSpecification to set
	 */
	private void setFunctionalSpecification(Activity functionalSpecification) {
		this.functionalSpecification = functionalSpecification;
	}

	/**
	 * @return the milpModel2Text
	 */
	private MILPModel2TextUtils getMilpModel2Text() {
		return milpModel2Text;
	}

	/**
	 * @param milpModel2Text the milpModel2Text to set
	 */
	private void setMilpModel2Text(MILPModel2TextUtils milpModel2Text) {
		this.milpModel2Text = milpModel2Text;
	}

	/**
	 * @return the resultsVisualizationBuffer
	 */
	public static String getResultsVisualizationBuffer() {
		return resultsVisualizationBuffer;
	}

	/**
	 * @param resultsVisualizationBuffer the resultsVisualizationBuffer to set
	 */
	public static void setResultsVisualizationBuffer(String resultsVisualizationBuffer) {
		SysML2MILPTransformation.resultsVisualizationBuffer = resultsVisualizationBuffer;
	}
	
	/**
	 * @param resultsVisualizationBuffer the resultsVisualizationBuffer to set
	 */
	public static void appendResultsVisualizationBuffer(String resultsVisualizationBuffer) {
		SysML2MILPTransformation.resultsVisualizationBuffer += resultsVisualizationBuffer;
	}

}
